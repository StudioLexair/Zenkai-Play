<!DOCTYPE html>
<html lang="es" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zenkai Play - Studio Lexair</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- HLS.js for streaming -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    
    <!-- PWA Configuration -->
    <meta name="theme-color" content="#0f0f0f">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Zenkai Play">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/2232/2232688.png">
    <!-- Inline Manifest (Base64 Encoded JSON) -->
    <link rel="manifest" href='data:application/manifest+json;base64,eyJuYW1lIjoiWmVua2FpIFBsYXkiLCJzaG9ydF9uYW1lIjoiWmVua2FpIiwic3RhcnRfdXJsIjoiLiIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwZjBmMGYiLCJ0aGVtZV9jb2xvciI6IiMwMDAwMDAiLCJpY29ucyI6W3sic3JjIjoiaHR0cHM6Ly9jZG4taWNvbnMtcG5nLmZsYXRpY29uLmNvbS81MTIvMjIzMi8yMjMyNjg4LnBuZyIsInNpemVzIjoiMTkyeDE5MiIsInR5cGUiOiJpbWFnZS9wbmcifSx7InNyYyIjoiaHR0cHM6Ly9jZG4taWNvbnMtcG5nLmZsYXRpY29uLmNvbS81MTIvMjIzMi8yMjMyNjg4LnBuZyIsInNpemVzIjoiNTEyeDUxMiIsInR5cGUiOiJpbWFnZS9wbmcifV19'>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f0f0f;
            color: #e5e5e5;
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        ::-webkit-scrollbar-thumb {
            background: #e50914; /* Netflix Red */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #b20710;
        }

        /* Loading Spinner */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #e50914;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Skeleton Loading Animation */
        @keyframes shimmer {
            0% { background-position: -1000px 0; }
            100% { background-position: 1000px 0; }
        }
        .skeleton {
            background: #1f2937; /* gray-800 */
            background-image: linear-gradient(to right, #1f2937 0%, #374151 20%, #1f2937 40%, #1f2937 100%);
            background-repeat: no-repeat;
            background-size: 1000px 100%;
            animation: shimmer 2s infinite linear forwards;
        }

        /* Hero Slider Transitions */
        .slide {
            transition: opacity 0.7s ease-in-out;
            opacity: 0;
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 0;
        }
        .slide.active {
            opacity: 1;
            pointer-events: auto;
            z-index: 10;
        }
        
        .slide-indicator {
            transition: all 0.3s;
            width: 8px;
            height: 8px;
            background-color: rgba(255,255,255,0.5);
        }
        .slide-indicator.active {
            width: 24px;
            background-color: #e50914;
        }

        /* Image Aspect Ratio */
        .aspect-card {
            aspect-ratio: 2/3;
        }

        /* Hide scrollbar for horizontal lists but allow scroll */
        .hide-scroll::-webkit-scrollbar {
            display: none;
        }
        .hide-scroll {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        /* Heart Animation */
        .heart-btn {
            transition: transform 0.2s;
        }
        .heart-btn:active {
            transform: scale(1.3);
        }

        /* Cinema Mode */
        .cinema-active #playerHeader, 
        .cinema-active #playerFooter {
            opacity: 0 !important;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        /* Show UI on hover in cinema mode */
        .cinema-active:hover #playerHeader, 
        .cinema-active:hover #playerFooter {
            opacity: 1 !important;
            pointer-events: auto;
        }
        .cinema-active {
            cursor: none;
        }
        .cinema-active:hover {
            cursor: default;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Navbar -->
    <nav class="sticky top-0 z-50 bg-black/90 backdrop-blur-md border-b border-gray-800">
        <div class="container mx-auto px-4 py-3 flex items-center justify-between gap-4">
            <!-- Logo -->
            <div class="flex items-center cursor-pointer flex-shrink-0" onclick="app.loadHome()">
                <i class="fa-solid fa-bolt text-3xl text-red-600 mr-2"></i>
                <span class="hidden sm:inline text-xl font-bold tracking-tight text-white">ZEN<span class="text-red-600">KAI</span></span>
            </div>

            <!-- Navigation Links -->
            <div class="hidden sm:flex items-center gap-6">
                <button onclick="app.loadHome()" class="text-gray-300 hover:text-white font-medium transition">Inicio</button>
                <button onclick="app.loadFavorites()" class="text-gray-300 hover:text-white font-medium transition">Mis Listas</button>
                
                <!-- Install App Button (Desktop) -->
                <button id="installBtnDesktop" onclick="app.installPwa()" class="hidden text-red-500 hover:text-white font-bold border border-red-500 px-3 py-1 rounded-full text-xs transition items-center gap-2 animate-pulse">
                    <i class="fa-solid fa-download"></i> APP
                </button>
                
                <!-- Settings Button -->
                <button onclick="app.toggleSettings()" class="text-gray-300 hover:text-white text-lg transition" title="Configuración y Datos">
                    <i class="fa-solid fa-gear"></i>
                </button>
            </div>

            <!-- Desktop Search -->
            <div class="hidden md:flex flex-1 max-w-lg relative">
                <input type="text" id="searchInput" placeholder="Buscar anime..." 
                    class="w-full bg-gray-800 text-white border border-gray-700 rounded-full py-2 px-5 focus:outline-none focus:border-red-600 focus:ring-1 focus:ring-red-600 transition-all">
                <button onclick="app.handleSearch()" class="absolute right-3 top-2 text-gray-400 hover:text-white cursor-pointer">
                    <i class="fa-solid fa-search"></i>
                </button>
            </div>

            <!-- Random Button (Desktop) -->
            <button onclick="app.loadRandom()" class="hidden md:flex items-center justify-center w-10 h-10 rounded-full bg-gray-800 hover:bg-red-600 text-white transition tooltip-btn" title="Anime Aleatorio">
                <i class="fa-solid fa-dice text-lg"></i>
            </button>

            <!-- Mobile Actions -->
            <div class="flex items-center gap-4 md:hidden">
                <!-- Install App Button (Mobile) -->
                <button id="installBtnMobile" onclick="app.installPwa()" class="hidden text-red-500 text-lg">
                    <i class="fa-solid fa-download"></i>
                </button>
                
                <button onclick="app.toggleSettings()" class="text-white text-xl">
                    <i class="fa-solid fa-gear"></i>
                </button>
                <button onclick="app.loadFavorites()" class="text-white text-xl">
                    <i class="fa-solid fa-heart"></i>
                </button>
                <button class="text-white text-xl" onclick="document.getElementById('mobileSearch').classList.toggle('hidden')">
                    <i class="fa-solid fa-search"></i>
                </button>
                <button onclick="app.loadRandom()" class="text-white text-xl">
                    <i class="fa-solid fa-dice"></i>
                </button>
            </div>
        </div>
        
        <!-- Mobile Search Bar -->
        <div id="mobileSearch" class="hidden md:hidden px-4 pb-3 bg-black/95">
            <div class="flex relative">
                <input type="text" id="mobileSearchInput" placeholder="Buscar..." 
                    class="w-full bg-gray-800 text-white rounded-lg py-2 px-4 focus:outline-none focus:border-red-600 border border-gray-700">
                <button onclick="app.handleSearch(true)" class="absolute right-3 top-2 text-gray-400">
                    <i class="fa-solid fa-arrow-right"></i>
                </button>
            </div>
        </div>
    </nav>

    <!-- Genres Bar -->
    <div class="container mx-auto px-4 py-4 overflow-x-auto whitespace-nowrap hide-scroll border-b border-gray-800 mb-4 sticky top-[60px] z-40 bg-[#0f0f0f]/95 backdrop-blur">
        <div id="genreContainer" class="flex gap-2">
            <!-- Genres injected here -->
        </div>
    </div>

    <!-- Main Content Area -->
    <main id="app" class="flex-grow container mx-auto px-4 py-6">
        <!-- Dynamic Content Injected Here -->
    </main>

    <!-- Footer -->
    <footer class="bg-black py-8 border-t border-gray-800 mt-auto">
        <div class="container mx-auto px-4 text-center text-gray-500 text-sm">
            <p class="mb-2">Powered by <span class="text-red-600 font-bold uppercase">Studio Lexair</span></p>
            <p class="text-xs text-gray-600 mb-4">Si tienes problemas de carga, cambia de servidor abajo.</p>
            <div class="mt-4 flex justify-center items-center gap-2">
                <span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                <button onclick="app.manualSwitchApi()" class="text-xs border border-gray-800 bg-gray-900 px-3 py-1 rounded-full hover:bg-gray-800 hover:text-white transition cursor-pointer" id="apiStatus">
                    Servidor: Default (Clic para cambiar)
                </button>
            </div>
        </div>
    </footer>

    <!-- Video Modal / Overlay -->
    <div id="videoOverlay" class="fixed inset-0 z-[60] bg-black hidden flex flex-col transition-colors duration-500">
        <div id="playerHeader" class="flex justify-between items-center p-4 bg-gray-900/80 backdrop-blur transition-opacity duration-300">
            <h3 id="playerTitle" class="text-white font-bold truncate pr-4">Reproduciendo</h3>
            <div class="flex items-center gap-4">
                 <!-- Player Mode Toggles (Fixed functionality) -->
                <div class="hidden md:flex bg-gray-800 rounded p-1 text-xs">
                    <button id="modeNative" class="px-3 py-1 hover:bg-gray-700 rounded text-white transition-colors">Nativo (Rápido)</button>
                    <button id="modeEmbed" class="px-3 py-1 hover:bg-gray-700 rounded text-white transition-colors">Embed (Compatible)</button>
                </div>
                
                <!-- PiP Toggle -->
                <button id="pipBtn" onclick="app.togglePiP()" class="hidden md:inline-block text-gray-300 hover:text-blue-400 text-xl transition-colors tooltip-btn mr-2" title="Picture-in-Picture">
                    <i class="fa-solid fa-clone"></i>
                </button>

                <!-- Cinema Mode Toggle -->
                <button onclick="app.toggleCinema()" class="text-gray-300 hover:text-yellow-400 text-xl transition-colors tooltip-btn" title="Modo Cine (Luces fuera)">
                    <i class="fa-solid fa-lightbulb"></i>
                </button>

                <button onclick="app.closePlayer()" class="text-white hover:text-red-600 text-2xl transition-colors ml-2">
                    <i class="fa-solid fa-times"></i>
                </button>
            </div>
        </div>
        
        <div class="flex-grow flex items-center justify-center bg-black relative w-full h-full">
            <div id="playerContainer" class="w-full h-full flex items-center justify-center">
                <!-- Video Element will be here -->
            </div>
        </div>

        <div id="playerFooter" class="p-4 bg-gray-900/90 text-center flex flex-col md:flex-row justify-center gap-3 items-center backdrop-blur transition-opacity duration-300">
            <!-- Player Controls -->
            <div class="flex gap-4">
                <button id="skipIntroBtn" class="hidden bg-white/10 hover:bg-white/20 text-white px-4 py-2 rounded text-sm font-bold transition flex items-center gap-2" onclick="app.skipIntro()">
                    <i class="fa-solid fa-forward"></i> +85s (Intro)
                </button>
                <button id="nextEpBtn" class="hidden bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded text-sm font-bold transition flex items-center gap-2" onclick="app.nextEpisode()">
                    Siguiente EP <i class="fa-solid fa-step-forward"></i>
                </button>
            </div>

            <div class="h-6 w-px bg-gray-700 hidden md:block"></div>

            <div class="md:hidden flex justify-center gap-2">
                 <button onclick="document.getElementById('modeNative').click()" class="bg-gray-800 px-3 py-1 rounded text-xs text-white">Nativo</button>
                 <button onclick="document.getElementById('modeEmbed').click()" class="bg-gray-800 px-3 py-1 rounded text-xs text-white">Embed</button>
            </div>
            
            <button class="bg-gray-800 px-4 py-2 rounded text-sm hover:bg-gray-700 transition cursor-pointer text-white flex items-center gap-2" onclick="app.tryNextServer()">
                <i class="fa-solid fa-server"></i> Cambiar Servidor
            </button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 z-[70] bg-black/80 hidden flex items-center justify-center backdrop-blur-sm" onclick="if(event.target === this) app.toggleSettings()">
        <div class="bg-gray-900 border border-gray-700 rounded-xl p-6 max-w-sm w-full shadow-2xl transform transition-all scale-100">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-bold text-white flex items-center gap-2">
                    <i class="fa-solid fa-gear text-red-600"></i> Configuración
                </h3>
                <button onclick="app.toggleSettings()" class="text-gray-400 hover:text-white">
                    <i class="fa-solid fa-times text-xl"></i>
                </button>
            </div>

            <div class="space-y-6">
                <!-- Backup Section -->
                <div>
                    <h4 class="text-sm font-bold text-gray-400 uppercase tracking-wider mb-3">Datos y Seguridad</h4>
                    <p class="text-xs text-gray-500 mb-3">Guarda tus favoritos e historial en un archivo para no perderlos.</p>
                    
                    <div class="flex flex-col gap-3">
                        <button onclick="app.storage.exportBackup()" class="w-full bg-gray-800 hover:bg-gray-700 text-white py-3 px-4 rounded-lg flex items-center justify-center gap-3 transition border border-gray-700">
                            <i class="fa-solid fa-download text-green-500"></i>
                            <div class="text-left">
                                <span class="block text-sm font-bold">Exportar Copia</span>
                                <span class="block text-[10px] text-gray-400">Descargar archivo .json</span>
                            </div>
                        </button>

                        <button onclick="document.getElementById('importFile').click()" class="w-full bg-gray-800 hover:bg-gray-700 text-white py-3 px-4 rounded-lg flex items-center justify-center gap-3 transition border border-gray-700">
                            <i class="fa-solid fa-upload text-blue-500"></i>
                            <div class="text-left">
                                <span class="block text-sm font-bold">Restaurar Copia</span>
                                <span class="block text-[10px] text-gray-400">Cargar archivo .json</span>
                            </div>
                        </button>
                        <input type="file" id="importFile" accept=".json" class="hidden" onchange="app.storage.importBackup(this)">
                    </div>
                </div>

                <div class="pt-4 border-t border-gray-800 text-center">
                    <p class="text-xs text-gray-600">Zenkai Play v3.0 - Studio Lexair</p>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript Application Logic -->
    <script>
        // Public Mirrors (Consumet) - Updated List
        // Note: AnimeFLV provider in Consumet often lacks /genre and /top-airing endpoints, 
        // so we will adapt the logic to use Search for everything.
        const API_MIRRORS = [
            'https://consumet-api-2.vercel.app/anime/animeflv',
            'https://consumet-jade-eta.vercel.app/anime/animeflv',
            'https://animet-api.vercel.app/anime/animeflv',
            'https://api.consumet.org/anime/animeflv',
            'https://c.delusionz.xyz/anime/animeflv'
        ];

        const GENRES = [
            "Acción", "Aventura", "Comedia", "Drama", "Fantasía", "Terror", 
            "Magia", "Misterio", "Psicológico", "Romance", "Ciencia Ficción", 
            "Recuentos de la vida", "Sobrenatural", "Thriller", "Ecchi", "Deportes"
        ];

        const app = {
            state: {
                apiIndex: 0,
                currentAnime: null,
                currentHls: null,
                sliderInterval: null,
                currentSlide: 0,
                page: 1,
                view: 'home', // home, search, genre
                activeFilter: null,
                listTab: 'all', // all, watching, completed, on_hold, dropped, plan_to_watch
                deferredPrompt: null
            },

            toggleSettings: () => {
                const el = document.getElementById('settingsModal');
                el.classList.toggle('hidden');
            },

            // --- LocalStorage Logic ---
            storage: {
                getFavorites: () => JSON.parse(localStorage.getItem('anime_favorites') || '[]'),
                
                isFavorite: (id) => {
                    const favs = app.storage.getFavorites();
                    return favs.some(a => a.id === id);
                },

                // Simplified toggle for Card View (Quick Add/Remove)
                toggleFavorite: (anime, event) => {
                    if(event) event.stopPropagation();
                    
                    let favs = app.storage.getFavorites();
                    const index = favs.findIndex(a => a.id === anime.id);

                    if (index !== -1) {
                        favs.splice(index, 1);
                    } else {
                        favs.push({
                            id: anime.id,
                            title: anime.title,
                            image: anime.image,
                            releaseDate: anime.releaseDate || '',
                            status: 'plan_to_watch' // Default status
                        });
                    }
                    localStorage.setItem('anime_favorites', JSON.stringify(favs));
                    
                    app.updateHeartIcon(anime.id);
                    if (document.getElementById('fav-container')) app.loadFavorites();
                },

                // Advanced Status Update for Details View
                updateStatus: (anime, newStatus) => {
                    let favs = app.storage.getFavorites();
                    const index = favs.findIndex(a => a.id === anime.id);

                    if (newStatus === "") {
                        // Remove from list
                        if (index !== -1) favs.splice(index, 1);
                    } else {
                        // Add or Update
                        const item = {
                            id: anime.id,
                            title: anime.title,
                            image: anime.image,
                            releaseDate: anime.releaseDate || '',
                            status: newStatus
                        };

                        if (index !== -1) {
                            favs[index] = { ...favs[index], status: newStatus };
                        } else {
                            favs.push(item);
                        }
                    }
                    localStorage.setItem('anime_favorites', JSON.stringify(favs));
                    
                    // Update UI feedback (Toast could go here)
                    const heartBtn = document.getElementById(`heart-details-${anime.id}`);
                    if (heartBtn) {
                        if (newStatus === "") {
                             heartBtn.className = 'fa-regular';
                        } else {
                             heartBtn.className = 'fa-solid text-red-600';
                        }
                    }
                },

                getHistory: (animeId) => {
                    return JSON.parse(localStorage.getItem(`anime_history_${animeId}`) || '{"watched": [], "lastEp": null}');
                },

                markEpisode: (animeId, episodeId, episodeNum) => {
                    const hist = app.storage.getHistory(animeId);
                    if (!hist.watched.includes(episodeId)) {
                        hist.watched.push(episodeId);
                    }
                    hist.lastEp = { id: episodeId, num: episodeNum, time: Date.now() };
                    localStorage.setItem(`anime_history_${animeId}`, JSON.stringify(hist));
                    
                    // Auto-update status to "watching" if not in list
                    if (!app.storage.isFavorite(animeId)) {
                        app.storage.toggleFavorite(app.state.currentAnime);
                        app.storage.updateStatus(app.state.currentAnime, 'watching');
                    }
                },

                // --- Backup System ---
                exportBackup: () => {
                    const data = {
                        favorites: app.storage.getFavorites(),
                        history: {},
                        timestamp: Date.now(),
                        version: 1
                    };

                    // Collect all history keys
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key.startsWith('anime_history_')) {
                            data.history[key] = JSON.parse(localStorage.getItem(key));
                        }
                    }

                    const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `zenkai_backup_${new Date().toISOString().slice(0,10)}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                },

                importBackup: (input) => {
                    const file = input.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            
                            if (data.favorites) {
                                localStorage.setItem('anime_favorites', JSON.stringify(data.favorites));
                            }
                            
                            if (data.history) {
                                Object.keys(data.history).forEach(key => {
                                    localStorage.setItem(key, JSON.stringify(data.history[key]));
                                });
                            }
                            
                            alert('Datos restaurados correctamente. La página se recargará.');
                            location.reload();
                        } catch (err) {
                            alert('Error al leer el archivo de respaldo.');
                            console.error(err);
                        }
                    };
                    reader.readAsText(file);
                }
            },

            updateHeartIcon: (id) => {
                const btn = document.getElementById(`heart-${id}`);
                if (!btn) return;
                
                const isFav = app.storage.isFavorite(id);
                if (isFav) {
                    btn.classList.remove('fa-regular', 'text-white');
                    btn.classList.add('fa-solid', 'text-red-600');
                } else {
                    btn.classList.remove('fa-solid', 'text-red-600');
                    btn.classList.add('fa-regular', 'text-white');
                }
            },

            // --- API Logic ---

            updateApiStatus: () => {
                const el = document.getElementById('apiStatus');
                if (!el) return;
                const host = new URL(API_MIRRORS[app.state.apiIndex]).hostname;
                el.innerText = `Servidor: ${host}`;
                el.classList.remove('text-green-400');
            },

            manualSwitchApi: () => {
                app.state.apiIndex = (app.state.apiIndex + 1) % API_MIRRORS.length;
                app.updateApiStatus();
                alert(`Cambiando a servidor alternativo: ${API_MIRRORS[app.state.apiIndex]}`);
                app.loadHome();
            },

            async request(type, param) {
                for (let i = 0; i < API_MIRRORS.length; i++) {
                    const idx = (app.state.apiIndex + i) % API_MIRRORS.length;
                    const baseUrl = API_MIRRORS[idx];
                    let url = '';
                    const page = app.state.page;

                    // ADAPTATION: The AnimeFLV provider in Consumet often crashes on /genre/ and /top-airing/.
                    // We map these to standard Search queries to ensure stability.
                    switch (type) {
                        case 'TOP': 
                            // Instead of /top-airing, we search for a mix of popular terms if the first fails
                            // But here we define the URL structure. The 'param' for TOP will be ignored or used as fallback keyword
                            url = `${baseUrl}/${encodeURIComponent(param || 'anime')}?page=${page}`; 
                            break;
                        case 'SEARCH': 
                            url = `${baseUrl}/${encodeURIComponent(param)}?page=${page}`; 
                            break;
                        case 'GENRE': 
                            // AnimeFLV Consumet endpoint usually doesn't have /genre/. 
                            // We use search instead, searching the genre name.
                            url = `${baseUrl}/${encodeURIComponent(param)}?page=${page}`; 
                            break;
                        case 'INFO': 
                            url = `${baseUrl}/info/${param}`; 
                            break;
                        case 'STREAM': 
                            url = `${baseUrl}/watch/${param}`; 
                            break;
                    }

                    try {
                        const response = await fetch(url);
                        if (!response.ok) throw new Error(`Status ${response.status}`);
                        return await response.json();
                    } catch (err) {
                        console.warn(`Mirror ${idx} failed.`);
                        if (i === API_MIRRORS.length - 1) throw new Error("All public mirrors failed");
                        app.state.apiIndex = (idx + 1) % API_MIRRORS.length;
                        app.updateApiStatus();
                    }
                }
            },

            async fetchTopAiring() {
                // Since there is no reliable "Top Airing" endpoint for AnimeFLV,
                // we simulate it by searching for currently popular keywords.
                const keywords = ['2024', 'action', 'aventura', 'shonen', 'isekai'];
                // Select a keyword based on minute to rotate content slightly or just fixed
                const keyword = keywords[Math.floor(Math.random() * keywords.length)];
                
                try {
                    // We pass the keyword to the TOP case which maps to search
                    const data = await app.request('TOP', keyword);
                    return data.results || data; 
                } catch (e) {
                    // Ultimate fallback
                    try {
                        const data = await app.request('SEARCH', 'dragon ball'); 
                        return data.results || [];
                    } catch (err) { return []; }
                }
            },

            async fetchSearch(query) {
                try {
                    const data = await app.request('SEARCH', query);
                    return data.results || [];
                } catch (e) { return []; }
            },

            async fetchGenre(genre) {
                try {
                    // We search for the genre name as a keyword since /genre/ endpoint is broken
                    const data = await app.request('GENRE', genre.toLowerCase());
                    return data.results || [];
                } catch (e) { return []; }
            },

            async fetchInfo(id) {
                try { return await app.request('INFO', id); } 
                catch (e) { return null; }
            },

            async fetchStream(id) {
                try { return await app.request('STREAM', id); } 
                catch (e) { return null; }
            },

            // --- UI Rendering ---

            showLoading: (type = 'home') => {
                let html = '';
                
                if (type === 'home') {
                    // Hero Skeleton
                    html += `
                        <div class="w-full h-[300px] sm:h-[400px] md:h-[500px] mb-10 rounded-2xl bg-gray-800 skeleton relative overflow-hidden"></div>
                    `;
                    // Grid Skeleton
                    html += `
                        <div class="flex items-center gap-3 mb-6">
                            <div class="w-1 h-8 bg-gray-700 rounded-full"></div>
                            <div class="h-8 w-48 bg-gray-800 rounded skeleton"></div>
                        </div>
                        <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-x-4 gap-y-8">
                    `;
                    for(let i=0; i<12; i++) {
                        html += `
                            <div>
                                <div class="aspect-card rounded-lg bg-gray-800 skeleton mb-3"></div>
                                <div class="h-4 w-3/4 bg-gray-800 rounded skeleton mb-2"></div>
                                <div class="h-3 w-1/2 bg-gray-800 rounded skeleton"></div>
                            </div>
                        `;
                    }
                    html += `</div>`;
                } 
                else if (type === 'details') {
                    html += `
                        <div class="flex flex-col md:flex-row gap-8 mb-8 animate-pulse">
                            <div class="w-full md:w-1/3 lg:w-1/4 flex-shrink-0">
                                <div class="aspect-card rounded-lg bg-gray-800 skeleton shadow-2xl"></div>
                            </div>
                            <div class="flex-grow space-y-4">
                                <div class="h-10 w-3/4 bg-gray-800 rounded skeleton"></div>
                                <div class="flex gap-4">
                                    <div class="h-10 w-32 bg-gray-800 rounded skeleton"></div>
                                    <div class="h-10 w-32 bg-gray-800 rounded skeleton"></div>
                                </div>
                                <div class="h-32 w-full bg-gray-800 rounded skeleton"></div>
                            </div>
                        </div>
                        <div class="bg-gray-900/50 p-6 rounded-xl border border-gray-800">
                             <div class="h-8 w-48 bg-gray-800 rounded skeleton mb-4"></div>
                             <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2">
                                ${Array(12).fill('<div class="h-10 bg-gray-800 rounded skeleton"></div>').join('')}
                             </div>
                        </div>
                    `;
                }
                else {
                    // Default / Search
                    html = `
                        <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                            ${Array(10).fill(`
                                <div>
                                    <div class="aspect-card rounded-lg bg-gray-800 skeleton mb-2"></div>
                                    <div class="h-4 w-2/3 bg-gray-800 rounded skeleton"></div>
                                </div>
                            `).join('')}
                        </div>`;
                }

                document.getElementById('app').innerHTML = html;
            },

            showError: (msg) => {
                document.getElementById('app').innerHTML = `
                    <div class="text-center py-20">
                        <i class="fa-solid fa-circle-exclamation text-4xl text-red-600 mb-4"></i>
                        <h2 class="text-xl font-bold mb-2">Ops, hubo un problema</h2>
                        <p class="text-gray-400 mb-6">${msg}</p>
                        <button onclick="app.loadHome()" class="bg-red-600 text-white px-6 py-2 rounded hover:bg-red-700 transition cursor-pointer">
                            Reintentar
                        </button>
                    </div>`;
            },

            createCard: (anime) => {
                // Escape quotes for object passing
                const animeJson = JSON.stringify(anime).replace(/"/g, '&quot;');
                const isFav = app.storage.isFavorite(anime.id);
                const heartClass = isFav ? 'fa-solid text-red-600' : 'fa-regular text-white';

                return `
                    <div class="group relative cursor-pointer transition-transform hover:scale-105 duration-300" onclick="app.loadDetails('${anime.id}')">
                        <div class="aspect-card rounded-lg overflow-hidden relative shadow-lg bg-gray-800">
                            <img src="${anime.image}" alt="${anime.title}" class="w-full h-full object-cover group-hover:opacity-80 transition-opacity" loading="lazy">
                            
                            <!-- Heart Button -->
                            <button onclick="app.storage.toggleFavorite(${animeJson}, event)" class="absolute top-2 right-2 z-10 w-8 h-8 flex items-center justify-center bg-black/50 rounded-full hover:bg-black/80 transition heart-btn">
                                <i id="heart-${anime.id}" class="${heartClass}"></i>
                            </button>

                            <div class="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black via-black/70 to-transparent p-3 pt-10">
                                <h3 class="text-white text-sm font-semibold line-clamp-2">${anime.title}</h3>
                            </div>
                        </div>
                    </div>
                `;
            },

            renderGenres: () => {
                const container = document.getElementById('genreContainer');
                if (!container) return;
                let html = '';
                GENRES.forEach(g => {
                    const isActive = app.state.view === 'genre' && app.state.activeFilter === g;
                    const style = isActive ? 'bg-red-600 text-white' : 'bg-gray-800 text-gray-300 hover:bg-gray-700 hover:text-white';
                    html += `
                        <button onclick="app.loadGenre('${g}')" class="${style} px-4 py-1.5 rounded-full text-sm font-medium transition whitespace-nowrap border border-gray-700/50">
                            ${g}
                        </button>
                    `;
                });
                container.innerHTML = html;
            },

            renderPagination: () => {
                const p = app.state.page;
                // Only show pagination if we have results (rudimentary check handled in caller)
                return `
                    <div class="col-span-full flex justify-center items-center gap-4 mt-8">
                        <button onclick="app.changePage(-1)" ${p === 1 ? 'disabled' : ''} class="px-4 py-2 bg-gray-800 rounded disabled:opacity-50 hover:bg-gray-700 transition">
                            <i class="fa-solid fa-chevron-left"></i> Anterior
                        </button>
                        <span class="text-gray-400 font-mono">Página ${p}</span>
                        <button onclick="app.changePage(1)" class="px-4 py-2 bg-gray-800 rounded hover:bg-gray-700 transition">
                            Siguiente <i class="fa-solid fa-chevron-right"></i>
                        </button>
                    </div>
                `;
            },

            changePage: (delta) => {
                const newPage = app.state.page + delta;
                if (newPage < 1) return;
                app.state.page = newPage;
                
                if (app.state.view === 'home') app.loadHome(false);
                else if (app.state.view === 'search') app.handleSearch(false, false); // isMobile=false, resetPage=false
                else if (app.state.view === 'genre') app.loadGenre(app.state.activeFilter, false);
                
                window.scrollTo({ top: 0, behavior: 'smooth' });
            },

            async loadGenre(genre, resetPage = true) {
                if (resetPage) app.state.page = 1;
                app.state.view = 'genre';
                app.state.activeFilter = genre;
                app.renderGenres(); // Update active state

                if (app.state.sliderInterval) clearInterval(app.state.sliderInterval);
                app.showLoading('search'); // Use search skeleton

                const results = await app.fetchGenre(genre);

                if (results.length === 0) {
                    if (app.state.page > 1) {
                         app.state.page--; // Revert if empty page
                         alert("No hay más resultados.");
                         app.loadGenre(genre, false);
                         return;
                    }
                    app.showError(`No se encontraron animes de género "${genre}"`);
                    return;
                }

                let html = `
                    <h2 class="text-2xl font-bold mb-6 flex items-center gap-2">
                        <span class="text-red-600">Género:</span> ${genre}
                    </h2>
                    <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                `;
                results.forEach(anime => html += app.createCard(anime));
                html += app.renderPagination();
                html += `</div>`;
                document.getElementById('app').innerHTML = html;
            },

            init: () => {
                app.renderGenres();
                app.updateApiStatus();
                app.loadHome();
                
                // Bind Mode buttons
                document.getElementById('modeNative').onclick = app.playerNative;
                document.getElementById('modeEmbed').onclick = app.playerIframe;

                document.getElementById('searchInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') app.handleSearch();
                });
                document.getElementById('mobileSearchInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') app.handleSearch(true);
                });

                // PWA Install Logic
                window.addEventListener('beforeinstallprompt', (e) => {
                    // Prevent the mini-infobar from appearing on mobile
                    e.preventDefault();
                    // Stash the event so it can be triggered later.
                    app.state.deferredPrompt = e;
                    // Update UI notify the user they can install the PWA
                    document.getElementById('installBtnDesktop').classList.remove('hidden');
                    document.getElementById('installBtnDesktop').classList.add('flex');
                    document.getElementById('installBtnMobile').classList.remove('hidden');
                });

                // Register Service Worker for PWA (Blob approach)
                if ('serviceWorker' in navigator) {
                    const swCode = "self.addEventListener('install', (e) => self.skipWaiting()); self.addEventListener('fetch', (e) => e.respondWith(fetch(e.request)));";
                    const blob = new Blob([swCode], {type: 'application/javascript'});
                    const swUrl = URL.createObjectURL(blob);
                    navigator.serviceWorker.register(swUrl)
                        .then(() => console.log('SW Registered'))
                        .catch(err => console.error('SW Error', err));
                }
            },

            installPwa: async () => {
                const promptEvent = app.state.deferredPrompt;
                if (!promptEvent) return;
                
                // Show the install prompt
                promptEvent.prompt();
                
                // Wait for the user to respond to the prompt
                const { outcome } = await promptEvent.userChoice;
                console.log(`User response to the install prompt: ${outcome}`);
                
                // We've used the prompt, so it can't be used again, discard it
                app.state.deferredPrompt = null;
                
                // Hide button
                document.getElementById('installBtnDesktop').classList.add('hidden');
                document.getElementById('installBtnDesktop').classList.remove('flex');
                document.getElementById('installBtnMobile').classList.add('hidden');
            },

            startHeroSlider: (topAnimes) => {
                if (app.state.sliderInterval) clearInterval(app.state.sliderInterval);
                app.state.currentSlide = 0;
                
                const showSlide = (index) => {
                    document.querySelectorAll('.slide').forEach((el, i) => {
                        if (i === index) el.classList.add('active');
                        else el.classList.remove('active');
                    });
                    document.querySelectorAll('.slide-indicator').forEach((el, i) => {
                        if (i === index) el.classList.add('active');
                        else el.classList.remove('active');
                    });
                };

                app.state.sliderInterval = setInterval(() => {
                    app.state.currentSlide = (app.state.currentSlide + 1) % topAnimes.length;
                    showSlide(app.state.currentSlide);
                }, 5000);
            },

            async loadHome(resetPage = true) {
                if (resetPage) {
                    app.state.page = 1;
                    app.state.view = 'home';
                    app.state.activeFilter = null;
                    app.renderGenres();
                }

                // Stop any previous slider
                if (app.state.sliderInterval) clearInterval(app.state.sliderInterval);
                
                app.showLoading('home');
                const animes = await app.fetchTopAiring();
                
                if (!animes || animes.length === 0) {
                    // If paging beyond limit
                    if (app.state.page > 1) {
                         app.state.page--; 
                         alert("No hay más resultados.");
                         app.loadHome(false);
                         return;
                    }
                    app.showError('No pudimos conectar con el servidor.');
                    return;
                }

                // Logic to display Hero Slider only on page 1
                let heroSection = '';
                let displayAnimes = animes;

                if (app.state.page === 1) {
                    const top3 = animes.slice(0, 3);
                    displayAnimes = animes.slice(3); // Remove top 3 from grid if on page 1

                    let slidesHtml = '';
                    let indicatorsHtml = '';

                    top3.forEach((anime, index) => {
                        const activeClass = index === 0 ? 'active' : '';
                        slidesHtml += `
                            <div class="slide ${activeClass} w-full h-full" onclick="app.loadDetails('${anime.id}')">
                                <div class="absolute inset-0 bg-cover bg-center transition-transform duration-1000 transform hover:scale-105" style="background-image: url('${anime.image}');"></div>
                                <div class="absolute inset-0 bg-gradient-to-t from-[#0f0f0f] via-black/40 to-transparent"></div>
                                <div class="absolute bottom-0 left-0 p-6 md:p-12 w-full md:w-3/4 lg:w-1/2 z-20">
                                    <span class="bg-red-600 text-white text-[10px] md:text-xs font-bold px-3 py-1 rounded-full mb-3 inline-block tracking-wider">TENDENCIA #${index + 1}</span>
                                    <h1 class="text-3xl md:text-5xl lg:text-6xl font-black text-white mb-3 leading-tight drop-shadow-xl line-clamp-2">${anime.title}</h1>
                                    <div class="flex items-center gap-3 mb-6">
                                        <span class="bg-white/20 backdrop-blur-md border border-white/30 text-white text-xs px-2 py-1 rounded">HD</span>
                                        <span class="bg-white/20 backdrop-blur-md border border-white/30 text-white text-xs px-2 py-1 rounded">SUB</span>
                                        ${anime.releaseDate ? `<span class="text-gray-300 text-sm font-medium">${anime.releaseDate}</span>` : ''}
                                    </div>
                                    <button class="bg-white text-black px-8 py-3 rounded-full font-bold hover:bg-gray-200 transition flex items-center gap-3 shadow-[0_0_20px_rgba(255,255,255,0.3)]">
                                        <i class="fa-solid fa-play text-xl"></i> VER AHORA
                                    </button>
                                </div>
                            </div>
                        `;
                        
                        indicatorsHtml += `
                            <button onclick="event.stopPropagation(); app.state.currentSlide = ${index}; document.querySelectorAll('.slide').forEach(e => e.classList.remove('active')); document.querySelectorAll('.slide')[${index}].classList.add('active');" 
                            class="slide-indicator rounded-full ${activeClass}"></button>
                        `;
                    });

                    heroSection = `
                        <div class="relative w-full h-[350px] sm:h-[450px] md:h-[550px] mb-10 rounded-2xl overflow-hidden shadow-2xl group cursor-pointer bg-gray-900">
                            ${slidesHtml}
                            <div class="absolute bottom-6 right-6 z-30 flex gap-2">
                                ${indicatorsHtml}
                            </div>
                        </div>
                    `;
                    app.startHeroSlider(top3);
                } else {
                    // Reset slider interval if not on page 1
                    if (app.state.sliderInterval) clearInterval(app.state.sliderInterval);
                }

                // Grid (Rest)
                let gridHtml = `
                    <h2 class="text-2xl font-bold mb-6 flex items-center gap-3">
                        <span class="w-1 h-8 bg-red-600 rounded-full"></span>
                        ${app.state.page === 1 ? 'Tendencias Ahora' : 'Más Resultados'}
                    </h2>
                    <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-x-4 gap-y-8">
                `;
                
                displayAnimes.forEach(anime => gridHtml += app.createCard(anime));
                gridHtml += app.renderPagination(); // Add Pagination
                gridHtml += `</div>`;
                
                document.getElementById('app').innerHTML = `<div class="animate-fade-in">${heroSection}${gridHtml}</div>`;
            },

            async handleSearch(isMobile = false, resetPage = true) {
                if (app.state.sliderInterval) clearInterval(app.state.sliderInterval);
                
                if (resetPage) {
                    const inputId = isMobile ? 'mobileSearchInput' : 'searchInput';
                    const query = document.getElementById(inputId).value;
                    if (!query.trim()) return;
                    
                    app.state.page = 1;
                    app.state.view = 'search';
                    app.state.activeFilter = query;
                    app.renderGenres();
                }
                
                const query = app.state.activeFilter;

                app.showLoading('search');
                const results = await app.fetchSearch(query);

                if (results.length === 0) {
                     if (app.state.page > 1) {
                         app.state.page--; 
                         alert("No hay más resultados.");
                         app.handleSearch(false, false);
                         return;
                    }
                    app.showError(`No se encontraron resultados para "${query}"`);
                    return;
                }

                let html = `
                    <h2 class="text-2xl font-bold mb-6">Resultados: <span class="text-red-500">${query}</span></h2>
                    <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                `;
                results.forEach(anime => html += app.createCard(anime));
                html += app.renderPagination();
                html += `</div>`;
                document.getElementById('app').innerHTML = html;
                document.getElementById('mobileSearch').classList.add('hidden');
            },

            loadFavorites: () => {
                const favs = app.storage.getFavorites();
                app.state.view = 'favorites';
                
                // Status Configuration
                const statuses = [
                    { id: 'all', label: 'Todos' },
                    { id: 'watching', label: 'Viendo' },
                    { id: 'plan_to_watch', label: 'Planeado' },
                    { id: 'completed', label: 'Completado' },
                    { id: 'dropped', label: 'Dropeado' }
                ];

                // Filter Logic
                const currentTab = app.state.listTab || 'all';
                const filteredFavs = currentTab === 'all' 
                    ? favs 
                    : favs.filter(a => (a.status || 'plan_to_watch') === currentTab);

                // Tabs HTML
                let tabsHtml = `<div class="flex flex-wrap gap-2 mb-8 border-b border-gray-800 pb-4">`;
                statuses.forEach(status => {
                    const isActive = currentTab === status.id;
                    const activeClass = isActive 
                        ? 'bg-red-600 text-white border-red-600' 
                        : 'bg-gray-800 text-gray-400 border-gray-700 hover:text-white hover:bg-gray-700';
                    
                    tabsHtml += `
                        <button onclick="app.state.listTab = '${status.id}'; app.loadFavorites()" 
                            class="px-4 py-2 rounded-full text-sm font-bold border transition ${activeClass}">
                            ${status.label} <span class="ml-1 opacity-60 text-xs bg-black/20 px-2 py-0.5 rounded-full">${
                                status.id === 'all' ? favs.length : favs.filter(a => (a.status || 'plan_to_watch') === status.id).length
                            }</span>
                        </button>
                    `;
                });
                tabsHtml += `</div>`;

                if (favs.length === 0) {
                    document.getElementById('app').innerHTML = `
                        <div class="text-center py-20 animate-fade-in">
                            <i class="fa-regular fa-heart text-6xl text-gray-700 mb-4"></i>
                            <h2 class="text-xl font-bold text-gray-400">Lista vacía</h2>
                            <p class="text-gray-500 mt-2">Empieza a agregar animes para organizarlos.</p>
                            <button onclick="app.loadHome()" class="mt-6 bg-gray-800 text-white px-6 py-2 rounded hover:bg-gray-700 transition">
                                Explorar
                            </button>
                        </div>
                    `;
                    return;
                }

                let html = `
                    <div class="animate-fade-in">
                        <div class="flex justify-between items-end mb-2">
                            <h2 class="text-2xl font-bold border-l-4 border-red-600 pl-3">Mi Biblioteca</h2>
                            <button onclick="app.toggleSettings()" class="text-sm text-gray-400 hover:text-white flex items-center gap-1"><i class="fa-solid fa-cog"></i> Opciones</button>
                        </div>
                        ${tabsHtml}
                `;

                if (filteredFavs.length === 0) {
                     html += `
                        <div class="text-center py-10 text-gray-500">
                            No hay animes en esta categoría.
                        </div>`;
                } else {
                    html += `<div id="fav-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">`;
                    filteredFavs.forEach(anime => html += app.createCard(anime));
                    html += `</div>`;
                }
                
                html += `</div>`;
                document.getElementById('app').innerHTML = html;
            },

            async loadDetails(id) {
                if (app.state.sliderInterval) clearInterval(app.state.sliderInterval);
                app.showLoading('details');
                
                // Update Hash for Direct Linking/Sharing
                window.location.hash = `#anime/${id}`;

                const anime = await app.fetchInfo(id);
                if (!anime) {
                    app.showError('Error al cargar detalles.');
                    return;
                }
                app.state.currentAnime = anime;
                
                // Get History
                const history = app.storage.getHistory(id);

                let continueBtn = '';
                if (history.lastEp) {
                    continueBtn = `
                        <button onclick="app.playEpisode('${history.lastEp.id}', ${history.lastEp.num})" 
                            class="bg-red-600 text-white px-6 py-3 rounded-full font-bold hover:bg-red-700 transition flex items-center gap-2 mb-4 md:mb-0 shadow-lg shadow-red-900/20">
                            <i class="fa-solid fa-play"></i> Continuar EP ${history.lastEp.num}
                        </button>
                    `;
                }

                let episodesHtml = '';
                if (anime.episodes && anime.episodes.length > 0) {
                    episodesHtml = `<div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2 max-h-96 overflow-y-auto pr-2 custom-scrollbar">`;
                    anime.episodes.forEach(ep => {
                        const isWatched = history.watched.includes(ep.id);
                        const bgClass = isWatched ? 'bg-gray-700 text-gray-400 border border-gray-600' : 'bg-gray-800 text-gray-300 hover:text-white hover:bg-red-700';
                        const checkMark = isWatched ? '<i class="fa-solid fa-check text-xs ml-1 text-green-500"></i>' : '';
                        
                        episodesHtml += `
                            <button onclick="app.playEpisode('${ep.id}', ${ep.number})" 
                                class="${bgClass} py-2 rounded text-sm transition font-medium flex items-center justify-center relative overflow-hidden group">
                                <span class="relative z-10">EP ${ep.number} ${checkMark}</span>
                            </button>
                        `;
                    });
                    episodesHtml += `</div>`;
                } else {
                    episodesHtml = '<p class="text-gray-500">No hay episodios disponibles.</p>';
                }

                // Get Status for Dropdown
                const favs = app.storage.getFavorites();
                const favItem = favs.find(a => a.id === anime.id);
                const currentStatus = favItem ? (favItem.status || 'plan_to_watch') : '';
                const isFav = !!favItem;
                const animeJson = JSON.stringify(anime).replace(/"/g, '&quot;');

                // --- Recommendations Logic ---
                // 1. Check API Recommendations
                let recs = anime.recommendations || [];
                // 2. Fallback: Fetch by Genre if API recs are empty
                if (recs.length === 0 && anime.genres && anime.genres.length > 0) {
                     // Fetch first genre
                     const genreRes = await app.fetchGenre(anime.genres[0]);
                     // Filter out current anime
                     recs = genreRes.filter(a => a.id !== anime.id).slice(0, 6);
                }
                
                let recsHtml = '';
                if (recs.length > 0) {
                    recsHtml = `
                        <div class="mt-8">
                            <h3 class="text-xl font-bold text-white mb-4 border-l-4 border-red-600 pl-3">Recomendaciones Similares</h3>
                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4">
                                ${recs.slice(0, 6).map(a => app.createCard(a)).join('')}
                            </div>
                        </div>
                    `;
                }

                document.getElementById('app').innerHTML = `
                    <div class="animate-fade-in">
                        <div class="flex flex-col md:flex-row gap-8 mb-8">
                            <div class="w-full md:w-1/3 lg:w-1/4 flex-shrink-0 relative group">
                                <img src="${anime.image}" class="w-full rounded-lg shadow-2xl transition group-hover:scale-[1.02]" alt="${anime.title}">
                            </div>
                            <div class="flex-grow">
                                <h1 class="text-3xl md:text-5xl font-black text-white mb-2 leading-tight">${anime.title}</h1>
                                
                                <div class="flex flex-wrap gap-3 mb-6 items-center">
                                    ${continueBtn}
                                    
                                    <div class="relative inline-block">
                                        <div class="flex items-center bg-gray-800 border border-gray-700 rounded-full px-1 hover:border-gray-500 transition h-10">
                                            <i id="heart-details-${anime.id}" class="${isFav ? 'fa-solid text-red-600' : 'fa-regular text-gray-400'} ml-3 mr-1"></i>
                                            <select onchange="app.storage.updateStatus(${animeJson}, this.value)" class="bg-transparent text-white text-sm font-medium py-2 px-2 pr-8 focus:outline-none appearance-none cursor-pointer h-full">
                                                <option value="" class="bg-gray-900 text-gray-400">No en lista</option>
                                                <option value="watching" class="bg-gray-900" ${currentStatus === 'watching' ? 'selected' : ''}>👀 Viendo</option>
                                                <option value="plan_to_watch" class="bg-gray-900" ${currentStatus === 'plan_to_watch' ? 'selected' : ''}>📅 Planeado</option>
                                                <option value="completed" class="bg-gray-900" ${currentStatus === 'completed' ? 'selected' : ''}>✅ Completado</option>
                                                <option value="on_hold" class="bg-gray-900" ${currentStatus === 'on_hold' ? 'selected' : ''}>⏸ En Espera</option>
                                                <option value="dropped" class="bg-gray-900" ${currentStatus === 'dropped' ? 'selected' : ''}>❌ Dropeado</option>
                                            </select>
                                            <i class="fa-solid fa-chevron-down text-xs text-gray-500 mr-3 pointer-events-none"></i>
                                        </div>
                                    </div>

                                    <!-- Share Button -->
                                    <button onclick="app.shareAnime(${animeJson})" class="w-10 h-10 rounded-full bg-gray-800 border border-gray-700 flex items-center justify-center hover:text-blue-400 hover:border-blue-400 transition" title="Compartir">
                                        <i class="fa-solid fa-share-nodes"></i>
                                    </button>
                                </div>

                                <div class="flex flex-wrap gap-2 mb-4 text-sm">
                                    <span class="bg-gray-800 px-3 py-1 rounded-full text-gray-300 font-medium">${anime.status || '?'}</span>
                                    <span class="bg-gray-800 px-3 py-1 rounded-full text-gray-300 font-medium">${anime.type || 'Anime'}</span>
                                    ${anime.releaseDate ? `<span class="bg-gray-800 px-3 py-1 rounded-full text-gray-300 font-medium">${anime.releaseDate}</span>` : ''}
                                </div>
                                <p class="text-gray-300 leading-relaxed mb-6 text-lg">${anime.description || 'Sin descripción.'}</p>
                                <div class="mb-2">
                                    <span class="text-gray-500 font-bold text-xs uppercase tracking-wider">Géneros</span>
                                    <div class="flex flex-wrap gap-2 mt-2">
                                        ${anime.genres ? anime.genres.map(g => `<span class="text-xs border border-gray-700 hover:border-red-600 hover:text-red-500 transition cursor-pointer px-3 py-1 rounded-full text-gray-400 bg-gray-900/50" onclick="app.loadGenre('${g}')">${g}</span>`).join('') : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="bg-gray-900/50 p-6 rounded-2xl border border-gray-800 backdrop-blur-sm">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="text-xl font-bold text-white flex items-center gap-2"><i class="fa-solid fa-list-ul text-red-600"></i> Episodios</h2>
                                <span class="bg-black/40 px-3 py-1 rounded text-sm text-gray-400">${anime.episodes ? anime.episodes.length : 0} Caps</span>
                            </div>
                            ${episodesHtml}
                        </div>
                        
                        ${recsHtml}

                    </div>
                `;
                window.scrollTo(0, 0);
            },

            async playEpisode(episodeId, episodeNum) {
                // Save History
                app.storage.markEpisode(app.state.currentAnime.id, episodeId, episodeNum);

                const overlay = document.getElementById('videoOverlay');
                const container = document.getElementById('playerContainer');
                
                // Update Title
                document.getElementById('playerTitle').innerText = `${app.state.currentAnime.title} - EP ${episodeNum}`;
                container.innerHTML = '<div class="loader"></div>';
                overlay.classList.remove('hidden');

                // Logic for Next Episode Button
                const episodes = app.state.currentAnime.episodes;
                const currentIdx = episodes.findIndex(e => e.id === episodeId);
                const nextEp = episodes[currentIdx + 1]; // Assuming sorted ascending usually, or dependent on API
                // Sometimes API returns episodes reversed. Let's rely on finding episodeNum + 1.
                // Better approach: Find by index in the array we displayed.
                
                // Determine next episode
                let nextEpisodeData = null;
                if (currentIdx !== -1 && currentIdx < episodes.length - 1) {
                    // Check if the array is sorted asc or desc. 
                    // Usually API returns high to low or low to high. 
                    // We'll trust the visual order (buttons are usually sorted). 
                    // Actually, let's just look for episodeNum + 1.
                    nextEpisodeData = episodes.find(e => e.number === episodeNum + 1);
                }
                
                const nextBtn = document.getElementById('nextEpBtn');
                if (nextEpisodeData) {
                    nextBtn.classList.remove('hidden');
                    // Important: Clear previous onclick logic to avoid stacking or closure issues
                    nextBtn.onclick = () => {
                        if (app.state.autoPlayTimer) clearInterval(app.state.autoPlayTimer);
                        const overlay = document.querySelector('.autoplay-overlay');
                        if (overlay) overlay.remove();
                        app.playEpisode(nextEpisodeData.id, nextEpisodeData.number);
                    };
                } else {
                    nextBtn.classList.add('hidden');
                }

                const data = await app.fetchStream(episodeId);

                if (!data || !data.sources) {
                    container.innerHTML = '<div class="text-center text-red-500 p-4">Error: No se encontraron fuentes de video.<br>Intenta cambiar de servidor o modo API.</div>';
                    return;
                }

                // Store stream data for mode toggling
                app.state.currentStreamData = data;
                app.playerNative();
            },

            skipIntro: () => {
                const video = document.querySelector('#playerContainer video');
                if (video) {
                    video.currentTime += 85;
                    // Toast or feedback could go here
                }
            },

            nextEpisode: () => {
                const nextBtn = document.getElementById('nextEpBtn');
                if (nextBtn && !nextBtn.classList.contains('hidden')) {
                    // Trigger the click event on the button which already has the parameters bound
                    nextBtn.click();
                }
            },

            playerNative: () => {
                const data = app.state.currentStreamData;
                const container = document.getElementById('playerContainer');
                document.getElementById('skipIntroBtn').classList.remove('hidden');
                
                if(!data) return;

                // Auto-hide UI logic could go here, but CSS hover handles it well for cinema mode

                const hlsSource = data.sources.find(s => s.isM3U8) || data.sources[0];
                
                if (app.state.currentHls) { app.state.currentHls.destroy(); app.state.currentHls = null; }
                
                // Fallback immediately if no useful HLS source
                if (!hlsSource || !hlsSource.url.includes('.m3u8')) {
                    app.playerIframe();
                    return;
                }

                container.innerHTML = '';
                const video = document.createElement('video');
                video.className = 'w-full h-full bg-black';
                video.controls = true;
                video.autoplay = true;
                video.crossOrigin = "anonymous";
                container.appendChild(video);

                // Enable Keyboard Shortcuts for this session
                document.addEventListener('keydown', app.handlePlayerKeys);
                
                // Auto-Play Listener
                video.addEventListener('ended', () => {
                   if(document.fullscreenElement) document.exitFullscreen();
                   app.startAutoPlayCountdown();
                });

                if (Hls.isSupported()) {
                    const hls = new Hls();
                    hls.loadSource(hlsSource.url);
                    hls.attachMedia(video);
                    hls.on(Hls.Events.MANIFEST_PARSED, () => video.play());
                    hls.on(Hls.Events.ERROR, (e, data) => {
                        if (data.fatal) {
                            hls.destroy();
                            app.playerIframe(); // Failover to iframe
                        }
                    });
                    app.state.currentHls = hls;
                } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    video.src = hlsSource.url;
                    video.addEventListener('loadedmetadata', () => video.play());
                    video.onerror = app.playerIframe;
                } else {
                    app.playerIframe();
                }
            },

            playerIframe: () => {
                if (app.state.currentHls) { app.state.currentHls.destroy(); app.state.currentHls = null; }
                // Remove shortcuts if switching to iframe
                document.removeEventListener('keydown', app.handlePlayerKeys);

                const data = app.state.currentStreamData;
                const container = document.getElementById('playerContainer');
                document.getElementById('skipIntroBtn').classList.add('hidden');
                
                let src = data.headers?.Referer; // Priority 1: Embed Referer
                if (!src) src = data.sources[0].url; // Priority 2: Direct URL
                
                container.innerHTML = `<iframe src="${src}" frameborder="0" allowfullscreen class="w-full h-full bg-black"></iframe>`;
            },

            closePlayer: () => {
                if (app.state.currentHls) { app.state.currentHls.destroy(); app.state.currentHls = null; }
                if (app.state.autoPlayTimer) clearInterval(app.state.autoPlayTimer);
                document.removeEventListener('keydown', app.handlePlayerKeys);

                document.getElementById('playerContainer').innerHTML = '';
                document.getElementById('videoOverlay').classList.add('hidden');
                document.getElementById('nextEpBtn').classList.add('hidden');
                document.getElementById('skipIntroBtn').classList.add('hidden');
                
                // Refresh details page to update "watched" status
                if (app.state.currentAnime) {
                    app.loadDetails(app.state.currentAnime.id);
                }
            },

            // --- Player Enhancements (Shortcuts, PiP, AutoPlay) ---

            handlePlayerKeys: (e) => {
                const video = document.querySelector('#playerContainer video');
                if (!video) return;

                // Only active if player is visible
                if (document.getElementById('videoOverlay').classList.contains('hidden')) return;

                switch(e.code) {
                    case 'Space':
                    case 'k':
                        e.preventDefault();
                        video.paused ? video.play() : video.pause();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        video.currentTime += 10;
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        video.currentTime -= 10;
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        if(video.volume < 1) video.volume = Math.min(1, video.volume + 0.1);
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        if(video.volume > 0) video.volume = Math.max(0, video.volume - 0.1);
                        break;
                    case 'KeyF':
                        e.preventDefault();
                        if (document.fullscreenElement) document.exitFullscreen();
                        else document.getElementById('playerContainer').requestFullscreen();
                        break;
                    case 'KeyM':
                        e.preventDefault();
                        video.muted = !video.muted;
                        break;
                }
            },

            togglePiP: async () => {
                const video = document.querySelector('#playerContainer video');
                if (!video) return;

                try {
                    if (document.pictureInPictureElement) {
                        await document.exitPictureInPicture();
                    } else {
                        await video.requestPictureInPicture();
                    }
                } catch (err) {
                    console.error('PiP Error:', err);
                }
            },

            startAutoPlayCountdown: () => {
                // Check if there is a next episode
                const nextBtn = document.getElementById('nextEpBtn');
                if (nextBtn.classList.contains('hidden')) return;

                const container = document.getElementById('playerContainer');
                
                // Create overlay
                const overlay = document.createElement('div');
                overlay.className = 'autoplay-overlay';
                overlay.innerHTML = `
                    <div class="text-white font-bold text-sm">Siguiente episodio en 5s...</div>
                    <div class="autoplay-circle"></div>
                    <button id="cancelAutoPlay" class="text-xs text-gray-300 hover:text-white underline mt-1">Cancelar</button>
                `;
                container.appendChild(overlay);

                let timeLeft = 5;
                app.state.autoPlayTimer = setInterval(() => {
                    timeLeft--;
                    if (timeLeft <= 0) {
                        clearInterval(app.state.autoPlayTimer);
                        if(document.body.contains(overlay)) {
                            app.nextEpisode();
                        }
                    }
                }, 1000);

                document.getElementById('cancelAutoPlay').onclick = (e) => {
                    e.stopPropagation();
                    clearInterval(app.state.autoPlayTimer);
                    overlay.remove();
                };
            },
            
            tryNextServer: () => {
                app.manualSwitchApi();
            },

            toggleCinema: () => {
                const overlay = document.getElementById('videoOverlay');
                const btn = overlay.querySelector('.fa-lightbulb');
                
                overlay.classList.toggle('cinema-active');
                
                if (overlay.classList.contains('cinema-active')) {
                    btn.classList.remove('fa-lightbulb');
                    btn.classList.add('fa-lightbulb'); // Keep icon but maybe style change?
                    btn.parentElement.classList.add('text-yellow-400');
                } else {
                    btn.parentElement.classList.remove('text-yellow-400');
                }
            },

            // --- New Discovery Features ---
            
            async loadRandom() {
                app.showLoading();
                // Strategy: Get a random genre, fetch content, pick one.
                const randomGenre = GENRES[Math.floor(Math.random() * GENRES.length)];
                try {
                    const results = await app.fetchGenre(randomGenre);
                    if (results && results.length > 0) {
                        const randomAnime = results[Math.floor(Math.random() * results.length)];
                        app.loadDetails(randomAnime.id);
                    } else {
                        // Fallback
                        app.loadHome();
                    }
                } catch(e) {
                    app.loadHome();
                }
            },

            shareAnime: (anime) => {
                const shareData = {
                    title: anime.title,
                    text: `Estoy viendo ${anime.title} en Zenkai Play!`,
                    url: window.location.href
                };

                if (navigator.share) {
                    navigator.share(shareData)
                        .then(() => console.log('Shared successfully'))
                        .catch((err) => console.log('Error sharing:', err));
                } else {
                    // Fallback to clipboard
                    navigator.clipboard.writeText(`${shareData.text} ${shareData.url}`)
                        .then(() => alert('Enlace copiado al portapapeles!'))
                        .catch(() => alert('Error al copiar enlace.'));
                }
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            app.init();
            
            // Check for Hash Routing (Deep Linking)
            const hash = window.location.hash;
            if (hash && hash.startsWith('#anime/')) {
                const id = hash.replace('#anime/', '');
                app.loadDetails(id);
            }
        });
    </script>
</body>
</html>
